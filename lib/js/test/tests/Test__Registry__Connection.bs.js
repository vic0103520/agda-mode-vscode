// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("rescript/lib/js/curry.js");
var Assert = require("assert");
var Caml_format = require("rescript/lib/js/caml_format.js");
var OS$AgdaModeVscode = require("../../src/Util/OS.bs.js");
var Nodechild_process = require("node:child_process");
var Util$AgdaModeVscode = require("../../src/Util/Util.bs.js");
var Test__Util$AgdaModeVscode = require("./Test__Util.bs.js");
var Registry__Connection$AgdaModeVscode = require("../../src/Registry__Connection.bs.js");

async function setup() {
  return await Registry__Connection$AgdaModeVscode.shutdown();
}

async function countChildAgdaProcesses() {
  var myPid = process.pid;
  var command = OS$AgdaModeVscode.onUnix ? "pgrep -P " + String(myPid) + " -f agda | wc -l" : "wmic process where \"Name='agda.exe' and ParentProcessId=" + String(myPid) + "\" get ProcessId /FORMAT:LIST | find /C \"ProcessId\"";
  var match = Util$AgdaModeVscode.Promise_.pending();
  var resolve = match[1];
  Nodechild_process.exec(command, (function (error, stdout, _stderr) {
          if (!(error == null)) {
            return resolve(0);
          }
          var output = stdout.toString().trim();
          if (output === "") {
            return resolve(0);
          }
          try {
            return resolve(Caml_format.int_of_string(output));
          }
          catch (exn){
            return resolve(0);
          }
        }));
  return await match[0];
}

describe("Registry__Connection", (function () {
        it("Singleton: acquire returns the same connection for different owners", (async function () {
                await setup();
                var makeCalled = {
                  contents: 0
                };
                var dummyConnection = "dummy-connection";
                var make = async function () {
                  makeCalled.contents = makeCalled.contents + 1 | 0;
                  return {
                          TAG: "Ok",
                          _0: dummyConnection
                        };
                };
                var res1 = await Registry__Connection$AgdaModeVscode.acquire("owner1", make);
                var res2 = await Registry__Connection$AgdaModeVscode.acquire("owner2", make);
                Curry._3(Assert.deepStrictEqual, res1, {
                      TAG: "Ok",
                      _0: dummyConnection
                    }, undefined);
                Curry._3(Assert.deepStrictEqual, res2, {
                      TAG: "Ok",
                      _0: dummyConnection
                    }, undefined);
                Curry._3(Assert.deepStrictEqual, makeCalled.contents, 1, undefined);
                var view = Registry__Connection$AgdaModeVscode.inspect();
                Curry._3(Assert.deepStrictEqual, view.userCount, 2, undefined);
                return Curry._3(Assert.deepStrictEqual, view.status, "Active", undefined);
              }));
        it("Serialization: concurrent execution is queued", (async function () {
                await setup();
                var make = async function () {
                  return {
                          TAG: "Ok",
                          _0: "dummy-connection"
                        };
                };
                await Registry__Connection$AgdaModeVscode.acquire("owner1", make);
                var executionOrder = [];
                var task1 = async function (param) {
                  executionOrder.push("task1-start");
                  await Util$AgdaModeVscode.Promise_.$$setTimeout(50);
                  executionOrder.push("task1-end");
                  return {
                          TAG: "Ok",
                          _0: undefined
                        };
                };
                var task2 = async function (param) {
                  executionOrder.push("task2-start");
                  return {
                          TAG: "Ok",
                          _0: undefined
                        };
                };
                var p1 = Registry__Connection$AgdaModeVscode.execute("owner1", task1);
                var p2 = Registry__Connection$AgdaModeVscode.execute("owner2", task2);
                await p1;
                await p2;
                return Curry._3(Assert.deepStrictEqual, executionOrder, [
                            "task1-start",
                            "task1-end",
                            "task2-start"
                          ], undefined);
              }));
        it("Reentrancy: nested execution from same owner is allowed", (async function () {
                await setup();
                var make = async function () {
                  return {
                          TAG: "Ok",
                          _0: "dummy-connection"
                        };
                };
                await Registry__Connection$AgdaModeVscode.acquire("owner1", make);
                var executionOrder = [];
                var task = async function (param) {
                  executionOrder.push("outer-start");
                  await Registry__Connection$AgdaModeVscode.execute("owner1", (async function (param) {
                          executionOrder.push("inner");
                          return {
                                  TAG: "Ok",
                                  _0: undefined
                                };
                        }));
                  executionOrder.push("outer-end");
                  return {
                          TAG: "Ok",
                          _0: undefined
                        };
                };
                await Registry__Connection$AgdaModeVscode.execute("owner1", task);
                return Curry._3(Assert.deepStrictEqual, executionOrder, [
                            "outer-start",
                            "inner",
                            "outer-end"
                          ], undefined);
              }));
        it("Reference Counting: connection is destroyed only when all users release it", (async function () {
                await setup();
                var make = async function () {
                  return {
                          TAG: "Ok",
                          _0: "dummy-connection"
                        };
                };
                await Registry__Connection$AgdaModeVscode.acquire("owner1", make);
                await Registry__Connection$AgdaModeVscode.acquire("owner2", make);
                Curry._3(Assert.deepStrictEqual, Registry__Connection$AgdaModeVscode.inspect().userCount, 2, undefined);
                await Registry__Connection$AgdaModeVscode.release("owner1");
                Curry._3(Assert.deepStrictEqual, Registry__Connection$AgdaModeVscode.inspect().userCount, 1, undefined);
                Curry._3(Assert.deepStrictEqual, Registry__Connection$AgdaModeVscode.inspect().status, "Active", undefined);
                await Registry__Connection$AgdaModeVscode.release("owner2");
                return Curry._3(Assert.deepStrictEqual, Registry__Connection$AgdaModeVscode.inspect().status, "Empty", undefined);
              }));
        describe("Real-world Scenario", (function () {
                this.timeout(30000);
                it("should share a single OS process between two different Agda files", (async function () {
                        await setup();
                        var initialCount = await countChildAgdaProcesses();
                        Curry._3(Assert.strictEqual, initialCount, 0, undefined);
                        var agdaA = await Test__Util$AgdaModeVscode.AgdaMode.makeAndLoad("GotoDefinition.agda");
                        var count1 = await countChildAgdaProcesses();
                        Curry._3(Assert.strictEqual, count1, 1, undefined);
                        var agdaB = await Test__Util$AgdaModeVscode.AgdaMode.makeAndLoad("Lib.agda");
                        var count2 = await countChildAgdaProcesses();
                        Curry._3(Assert.strictEqual, count2, 1, undefined);
                        var view = Registry__Connection$AgdaModeVscode.inspect();
                        Curry._3(Assert.deepStrictEqual, view.userCount, 2, undefined);
                        Curry._3(Assert.deepStrictEqual, view.status, "Active", undefined);
                        await Test__Util$AgdaModeVscode.AgdaMode.quit(agdaA);
                        await Test__Util$AgdaModeVscode.AgdaMode.quit(agdaB);
                        var finalCount = await countChildAgdaProcesses();
                        return Curry._3(Assert.strictEqual, finalCount, 0, undefined);
                      }));
              }));
      }));

exports.setup = setup;
exports.countChildAgdaProcesses = countChildAgdaProcesses;
/*  Not a pure module */
